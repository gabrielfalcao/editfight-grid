<!DOCTYPE html>
<html>

<head>
  <title>EditFight.com</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html {
      font-family: sans-serif;
    }

    *,
    *:before,
    *:after {
      box-sizing: border-box;
      font-family: inherit;
      margin: 0;
      padding: 0;
    }





    #error {
      position: fixed;
      z-index: 100;
      top: 35%;
      left: 0;
      right: 0;

      padding: 1em;
      background: crimson;
      color: white;
      text-align: center;
    }

    .hidden {
      display: none;
    }




    #page {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;

      display: flex;
      flex-direction: column;
    }

    #colorsHolder {
      flex-shrink: 0;
    }

    #rest {
      height: 100%;
      flex-grow: 1;

      display: flex;
      flex-direction: column;
    }

    #canvasHolder {
      flex: 1 1 auto;
    }

    #commentsHolder {
      flex: 1 20 auto;
      min-width: 20em;
    }

    @media (min-aspect-ratio: 3/4) {
      #rest {
        flex-direction: row;
      }
    }




    #colorsHolder {
      background: #ccc;
    }

    #canvasHolder {
      background: #9a9a9a;
      background-image: linear-gradient(45deg, #b4b4b4 25%, transparent 25%), linear-gradient(-45deg, #b4b4b4 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #b4b4b4 75%), linear-gradient(-45deg, transparent 75%, #b4b4b4 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    #commentsHolder {
      display: flex;
      flex-direction: column;

      background: #fff;
      padding: 0.5em;
    }

    #countHolder {
      font-size: 75%;
      opacity: 0.5;
      text-align: center;
    }

    #comments {
      -webkit-overflow-scrolling: touch;
      overflow: scroll;
      list-style-type: none;
    }

    .comment {
      margin: 0.5em 0;
    }

    .comment a {
      color: inherit;
    }

    .comment.admin {
      font-weight: bold;
      background: lightyellow;
    }

    .comment.status {
      font-weight: bold;
      background: lightcyan;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;

      position: relative;
      cursor: crosshair;
    }

    #textbox {
      font-size: inherit;
      padding: 0.5em;
      width: 100%;
    }

    #colorsHolder {
      display: flex;
      overflow: auto;
      /* padding: 0.25em; */
      list-style-type: none;
      align-items: center;
      -webkit-overflow-scrolling: touch;
    }

    .colorBox {
      position: relative;
      min-width: 2em;
      min-height: 2em;
      margin: 1px;
      cursor: pointer;
    }

    #colorsHolder .link {
      color: blue;
      margin: 0 0.25em;
      padding: 0.25em 0.5em;
    }

    #colorsHolder>span {
      white-space: nowrap;
    }

    .tool {
      margin: 0 0.25em;
      padding: 0.25em 0.5em;
      white-space: nowrap;

      cursor: pointer;
      font-weight: bold;
      color: #fff;
      background: crimson;
      border-bottom: 3px solid darkred;
      border-radius: 4px;
    }

    .tool.active {
      background: darkred;
    }

    .colorBox.selected {
      border-radius: 50%;
    }

    .userCircle {
      position: absolute;
      z-index: 200;
      color: #fff;
      font-size: 10px;
      visibility: none;
      text-shadow: 0 0 2px #000;
      pointer-events: none;
    }

    .userCircle.zoomed {
      font-size: 50px;
      border-width: 6px;
    }

    .userCircle.fading {
      transition: opacity 2s ease-out;
      opacity: 0;
      visibility: initial;
    }
  </style>
</head>

<body>

  <div id="error" class="hidden">
    There was once an error. One day, the error existed. The end.
  </div>

  <div id="page">

    <ol id="colorsHolder">
      <a class="link" href="/gifs.html">gifs</a>
      <span>Made with &lt;3
        <a target="blank" rel="noopener" href="https://www.paypal.com/cgi-bin/webscr?business=sbdegutis@gmail.com&cmd=_donations&item_name=EditFight%20donation&no_shipping=1">Donate</a>
      </span>
    </ol>

    <div id="rest">

      <div id="canvasHolder">
        <canvas id="canvas" width="1000" height="1000"></canvas>
      </div>

      <div id="commentsHolder">
        <form autocomplete="off" id="commentForm">
          <input autofocus autocomplete="off" id="textbox" type="text" placeholder="Chat box">
        </form>
        <div id="countHolder">(There are
          <span id="count">n</span> other people here.)</div>
        <ol id="comments"></ol>
      </div>

    </div>

  </div>

  <script>
    "use strict";

    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // color palette based on http://alumni.media.mit.edu/~wad/color/palette.html
    const palette = [
      { color: "#000000", name: "Black" },
      { color: "#575757", name: "Dark Gray" },
      { color: "#ad2323", name: "Red" },
      { color: "#2a4bd7", name: "Blue" },
      { color: "#1d6914", name: "Green" },
      { color: "#814a19", name: "Brown" },
      { color: "#8126c0", name: "Purple" },
      { color: "#a0a0a0", name: "Light Gray" },
      { color: "#81c57a", name: "Light Green" },
      { color: "#9dafff", name: "Light Blue" },
      { color: "#29d0d0", name: "Cyan" },
      { color: "#ff9233", name: "Orange" },
      { color: "#ffee33", name: "Yellow" },
      { color: "#e9debb", name: "Tan" },
      { color: "#ffcdf3", name: "Pink" },
      { color: "#ffffff", name: "White" },
    ];

    const countElement = document.getElementById('count');
    const errorElement = document.getElementById('error');
    const commentsElement = document.getElementById('comments');
    const colorsHolder = document.getElementById('colorsHolder');
    const commentForm = document.getElementById('commentForm');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let currentColor = parseInt(localStorage.getItem('currentColor') || '0');
    let myName = localStorage.getItem('myName');
    let grid = [];
    let zooming = false;
    let zoom = null;
    let zoomButton = null;
    let gridButton = null;
    const colorBoxes = [];
    let selectedColorBox = null;
    let showGrid = !!localStorage.getItem('showGrid');

    for (let y = 0; y < 100; y++) {
      const row = [];
      for (let x = 0; x < 100; x++) {
        row.push(0);
      }
      grid.push(row);
    }

    canvas.onmousemove = mouseMovedOverCanvas;
    canvas.onclick = clickedCanvas;
    canvas.onmouseleave = mouseLeftCanvas;
    commentForm.onsubmit = sendMessage;
    document.onvisibilitychange = repaintVisibleCells;
    document.onkeydown = keyPressed;

    canvas.ontouchstart = canvasTouchStart;
    canvas.ontouchmove = canvasTouchMove;
    canvas.ontouchend = canvasTouchEnd;

    setupToolbar();

    const socket = connect(
      `ws://${location.host}/app`,
      {

        __open() {
          const cheatcode = localStorage.getItem('cheatcode');
          if (cheatcode) socket.send({ [cheatcode]: true });
        },

        count(n) {
          countElement.innerText = n - 1;
        },

        canvas(canvas) {
          for (let i = 0; i < canvas.length; i++) {
            const hex = canvas.charAt(i);
            const c = parseInt(hex, 16);

            let x = i % 100;
            let y = Math.floor(i / 100);

            grid[y][x] = c;

            paintSpot(x, y, c);
          }
        },

        pixels(pixels) {
          pixels.forEach(({ x, y, c, id, hash }) => {
            grid[y][x] = c;
            paintSpot(x, y, c);

            if (hash) {
              showUserCircle(x, y, id, colorForHash(hash));
            }
          });
        },

        message(msg) {
          appendMessage(msg);
        },

        messages(messages) {
          commentsElement.innerHTML = '';
          for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            appendMessage(msg);
          }
        },

      }
    )

    let lastHoveredSpot = null;
    function mouseMovedOverCanvas(e) {
      const newSpot = coordinatesFor(e);
      let { x, y } = newSpot;

      if (zooming) {
        repaintVisibleCells();

        const normalizedCoordinates = getZoomCoordinates(x, y);
        x = normalizedCoordinates.x;
        y = normalizedCoordinates.y;

        ctx.lineWidth = 5;
        ctx.strokeStyle = '#ccc';
        ctx.strokeRect(x * 10, y * 10, 10 * 20, 10 * 20);

        return;
      }

      if (lastHoveredSpot && lastHoveredSpot.x === x && lastHoveredSpot.y === y)
        return;

      if (lastHoveredSpot) {
        const { x, y } = lastHoveredSpot;
        paintSpot(x, y, grid[y][x]);
      }

      paintSpot(x, y, currentColor);

      lastHoveredSpot = newSpot;
    }

    function getZoomCoordinates(x, y) {
      x -= 10;
      y -= 10;

      if (x < 0) x = 0;
      if (y < 0) y = 0;

      if (x > 80) x = 80;
      if (y > 80) y = 80;

      return { x, y };
    }

    function mouseLeftCanvas(e) {
      if (!lastHoveredSpot) return;
      const { x, y } = lastHoveredSpot;
      paintSpot(x, y, grid[y][x]);
      lastHoveredSpot = null;
    }

    function paintSpot(x, y, c) {
      const color = palette[c] ? palette[c].color : c;

      let px = x * 10;
      let py = y * 10;
      let pw = 10;
      let ph = 10;

      if (zoom) {
        const scale = 5;

        px = (x - zoom.x) * 10 * scale;
        py = (y - zoom.y) * 10 * scale;

        pw *= scale;
        ph *= scale;
      }

      ctx.fillStyle = color;
      ctx.fillRect(px, py, pw, ph);

      if (showGrid) {
        ctx.fillStyle = '#ccc4';
        ctx.fillRect(px, py, pw, ph);
        px += 1;
        py += 1;
        pw -= 2;
        ph -= 2;
      }

      ctx.fillStyle = color;
      ctx.fillRect(px, py, pw, ph);
    }

    function repaintVisibleCells() {
      for (let y = (zoom ? zoom.y : 0); y < (zoom ? zoom.y + 20 : 100); y++) {
        for (let x = (zoom ? zoom.x : 0); x < (zoom ? zoom.x + 20 : 100); x++) {
          paintSpot(x, y, grid[y][x]);
        }
      }
    }

    const keyHandlers = {
      [37](e) { if (!zoom) return; e.preventDefault(); zoom.x--; if (zoom.x < 0) zoom.x = 0; repaintVisibleCells(); },
      [39](e) { if (!zoom) return; e.preventDefault(); zoom.x++; if (zoom.x > 80) zoom.x = 80; repaintVisibleCells(); },
      [38](e) { if (!zoom) return; e.preventDefault(); zoom.y--; if (zoom.y < 0) zoom.y = 0; repaintVisibleCells(); },
      [40](e) { if (!zoom) return; e.preventDefault(); zoom.y++; if (zoom.y > 80) zoom.y = 80; repaintVisibleCells(); },
      [189](e) { e.preventDefault(); previousColor(); },
      [187](e) { e.preventDefault(); nextColor(); },
      [32](e) { e.preventDefault(); toggleZoom(); },
    };

    function keyPressed(e) {
      if (document.activeElement !== textbox) {
        const fn = keyHandlers[e.keyCode];
        if (fn) fn(e);
      }
    }

    function showUserCircle(x, y, id, color) {
      const offx = zoom ? zoom.x : 0;
      const offy = zoom ? zoom.y : 0;
      const scale = zoom ? 5 : 1;

      const tw = (canvas.clientWidth / 100) * scale;
      const th = (canvas.clientHeight / 100) * scale;

      const canvasx = canvas.offsetLeft;
      const canvasy = canvas.offsetTop;

      const el = document.createElement('span');
      el.innerText = id;
      el.className = 'userCircle';
      if (zoom) el.classList.add('zoomed');
      document.body.appendChild(el);

      const halfWidth = el.offsetWidth / 2.0;
      const fullHeight = el.offsetHeight + 2;
      const px = ((x - offx) * tw + canvasx - halfWidth + (tw / 2));
      const py = ((y - offy) * th + canvasy - fullHeight);

      el.style.left = px + 'px';
      el.style.top = py + 'px';
      el.classList.add('fading');

      setTimeout(() => {
        el.remove();
      }, 2000);
    }

    function clickedCanvas(event) {
      let { x, y } = coordinatesFor(event);

      if (zooming) {
        const normalizedCoordinates = getZoomCoordinates(x, y);
        zoom = normalizedCoordinates;
        zooming = false;
        repaintVisibleCells();
        return;
      }

      socket.send({
        paint: { x, y, c: currentColor }
      });
    }

    function coordinatesFor(event) {
      const rect = canvas.getBoundingClientRect();

      let x = Math.floor((event.clientX - rect.left) / (canvas.clientWidth / 100));
      let y = Math.floor((event.clientY - rect.top) / (canvas.clientHeight / 100));

      if (zoom) {
        x = Math.floor(x / 5) + zoom.x;
        y = Math.floor(y / 5) + zoom.y;
      }

      return { x, y };
    }

    function appendMessage(msg) {
      if (msg.id) msg.text = `(${msg.id}) ${msg.text}`;
      const commentEl = document.createElement('li');
      commentEl.className = 'comment';
      commentEl.innerText = msg.text;
      commentEl.innerHTML = commentEl.innerHTML.replace(/(https?:\/\/[^\s]+)/g, "<a href='$1' target=_blank rel=noopener>$1</a>");
      if (msg.hash) commentEl.style.color = colorForHash(msg.hash);
      if (msg.admin) commentEl.classList.add('admin');
      if (msg.status) commentEl.classList.add('status');
      commentsElement.insertAdjacentElement('afterbegin', commentEl);
    }

    function toggleZoom() {
      if (zoom || zooming) {
        zooming = false;
        zoom = null;
        repaintVisibleCells();
        zoomButton.classList.remove('active');
      }
      else {
        zooming = true;
        zoomButton.classList.add('active');
      }
    }

    function toggleGrid() {
      showGrid = !showGrid;
      localStorage.setItem('showGrid', showGrid ? 'yes' : '');

      if (showGrid)
        gridButton.classList.add('active');
      else
        gridButton.classList.remove('active');

      repaintVisibleCells();
    }

    function setupToolbar() {
      zoomButton = addTool('Zoom', () => { toggleZoom(); });

      gridButton = addTool('Grid', () => {
        toggleGrid();
      });
      if (showGrid) gridButton.classList.add('active');

      if (!isMobile) {
        canvas.style.cursor = localStorage.getItem('crosshairStyle') || 'crosshair';
        addTool('Crosshair', () => {
          if (canvas.style.cursor === 'crosshair') {
            canvas.style.cursor = 'none';
          }
          else {
            canvas.style.cursor = 'crosshair';
          }
          localStorage.setItem('crosshairStyle', canvas.style.cursor);
        });
      }

      addColorButtons();

      chooseColor(currentColor);
    }

    function addColorButtons() {
      for (let i = 0; i < 16; i++) {
        const colorBox = document.createElement('li');
        colorBox.className = 'colorBox';
        colorBox.style.backgroundColor = palette[i].color;
        colorBox.title = palette[i].name;
        colorBox.onclick = () => {
          chooseColor(i);
        };

        colorBoxes.push(colorBox);

        if (currentColor === i) {
          colorBox.onclick();
        }

        colorsHolder.appendChild(colorBox);
      }
    }

    function chooseColor(color) {
      if (color < 0) color = 15;
      if (color > 15) color = 0;

      if (selectedColorBox) { selectedColorBox.classList.remove('selected'); }
      const colorBox = colorBoxes[color];
      colorBox.classList.add('selected');
      selectedColorBox = colorBox;

      currentColor = color;
      localStorage.setItem('currentColor', color);
    }

    function nextColor() {
      chooseColor(currentColor + 1);
    }

    function previousColor() {
      chooseColor(currentColor - 1);
    }

    function addTool(name, fn) {
      const el = document.createElement('li');
      el.className = 'tool';
      el.innerText = name;
      el.onclick = fn;
      colorsHolder.appendChild(el);
      return el;
    }

    let dragInfo = null;

    function getTouchPoint(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
      }
    }

    function canvasTouchStart(e) {
      if (zoom && e.touches.length === 1) {
        dragInfo = { ...getTouchPoint(e) };
      }
    }

    function canvasTouchMove(e) {
      if (zoom && dragInfo && e.touches.length === 1) {
        const { x, y } = getTouchPoint(e);

        if (!dragInfo.active) {
          if (Math.abs(x - dragInfo.x) > 20 || Math.abs(y - dragInfo.y) > 20) {
            dragInfo = {
              x, y,
              active: true
            };
            zoom.start = { x: zoom.x, y: zoom.y };
          }
        }

        if (dragInfo.active) {
          e.preventDefault();

          const offx = Math.round((x - dragInfo.x) / (canvas.clientWidth / 100) / 5);
          const offy = Math.round((y - dragInfo.y) / (canvas.clientHeight / 100) / 5);

          zoom.x = zoom.start.x - offx;
          zoom.y = zoom.start.y - offy;

          if (zoom.x < 0) zoom.x = 0;
          if (zoom.x > 80) zoom.x = 80;
          if (zoom.y < 0) zoom.y = 0;
          if (zoom.y > 80) zoom.y = 80;

          repaintVisibleCells();
        }
      }
    }

    function canvasTouchEnd(e) {
      if (dragInfo) {
        dragInfo = null;
      }
    }

    function sendMessage(e) {
      e.preventDefault();
      let text = textbox.value;
      if (text.trim().length === 0) return;

      const maybeName = text.match(/^\/(?:nick|name)\s+(\w+)$/);
      if (myName) text = `[${myName}] ${text}`;
      textbox.value = '';
      socket.send({ text });

      if (maybeName && maybeName[1]) {
        myName = maybeName[1];
        localStorage.setItem('myName', myName);
      }
    }

    function connect(addr, handler) {
      const connection = new WebSocket(addr);

      connection.onopen = (e) => {
        handler.__open();
      }

      connection.onclose = (e) => {
        window.onbeforeunload = null;
        showError("Disconnected; reloading.");
        setTimeout(() => window.location.reload(true), 500);
      }

      connection.onmessage = (message) => {
        const json = JSON.parse(message.data);
        Object.entries(json).forEach(([key, value]) => {
          handler[key](value);
        });
      }

      return {
        send(msg) {
          connection.send(JSON.stringify(msg));
        }
      }
    }

    function colorForHash(hash) {
      const hue = hash % 180 + 180;
      const sat = Math.abs(hash) % 50 + 30;
      const light = Math.abs(hash) % 60 + 20;
      return `hsl(${hue}, ${sat}%, ${light}%)`;
    }

    function showError(text) {
      errorElement.innerText = text;
      errorElement.classList.remove('hidden');
    }
  </script>
</body>

</html>