<!DOCTYPE html>
<html>

<head>
  <title>EditFight.com</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html {
      font-family: sans-serif;
    }

    *,
    *:before,
    *:after {
      box-sizing: border-box;
      font-family: inherit;
      margin: 0;
      padding: 0;
    }





    #error {
      position: fixed;
      z-index: 100;
      top: 35%;
      left: 0;
      right: 0;

      padding: 1em;
      background: crimson;
      color: white;
      text-align: center;
    }

    .hidden {
      display: none;
    }




    #page {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;

      display: flex;
      flex-direction: column;
    }

    #colorsHolder {
      flex-shrink: 0;
    }

    #rest {
      height: 100%;
      flex-grow: 1;

      display: flex;
      flex-direction: column;
    }

    #canvasHolder {
      flex: 1 1 auto;
    }

    #commentsHolder {
      flex: 1 1 auto;
      min-width: 0;
    }

    @media (min-aspect-ratio: 3/4) {
      #rest {
        flex-direction: row;
      }
    }




    #colorsHolder {
      -webkit-overflow-scrolling: touch;
      background: #ccc;
    }

    #canvasHolder {
      padding: 10px;
      background: #9a9a9a;
      background-image: linear-gradient(45deg, #b4b4b4 25%, transparent 25%), linear-gradient(-45deg, #b4b4b4 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #b4b4b4 75%), linear-gradient(-45deg, transparent 75%, #b4b4b4 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    #commentsHolder {
      display: flex;
      flex-direction: column;

      background: #fff;
      padding: 0.5em;
    }

    #countHolder {
      font-size: 75%;
      opacity: 0.5;
      text-align: center;
    }

    #comments {
      -webkit-overflow-scrolling: touch;
      overflow: scroll;
      list-style-type: none;
    }

    .comment {
      margin: 0.5em 0;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;

      position: relative;
    }

    .userEventCircle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }

    .userEventCircle.hiding {
      opacity: 0;
      transition: opacity 1s linear;
    }

    #textbox {
      font-size: inherit;
      padding: 0.5em;
      width: 100%;
    }

    #colorsHolder {
      display: flex;
      overflow: auto;
      /* padding: 0.25em; */
    }

    .colorBox {
      position: relative;
      min-width: 2em;
      min-height: 2em;
      list-style-type: none;
      /* margin: 0.25em; */
    }

    .colorBox.selected {
      border-radius: 50%;
    }

    #welcome {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 2000;
      background: #e6e4d9;
      padding: 0 1em;
      overflow: auto;
    }

    #welcomeContent {
      margin: 0 auto;
      width: 95%;
      max-width: 30rem;
    }

    #welcomeContent>* {
      margin: 1rem 0;
    }

    #welcome button {
      background: #19a22d;
      border: 0;
      border-bottom: 3px solid #0e731d;
      padding: 0.5em 1em;
      font-size: inherit;
      border-radius: 3px;
      color: #fff;
      cursor: pointer;
    }

    #welcome .emphasis {
      font-weight: bold;
      color: crimson;
    }

    #welcome.hidden {
      display: none;
    }
  </style>
</head>

<body>

  <div id="error" class="hidden">
    There was once an error. One day, the error existed. The end.
  </div>

  <div id="page">

    <ol id="colorsHolder">
      Color chooser will go here soon.
    </ol>

    <div id="rest">

      <div id="canvasHolder">
        <canvas id="canvas" width="1000" height="1000"></canvas>
      </div>

      <div id="commentsHolder">
        <form autocomplete="off" id="commentForm">
          <input autofocus autocomplete="off" id="textbox" type="text" placeholder="Chat box">
        </form>
        <div id="countHolder">(There are
          <span id="count">n</span> other people here.)</div>
        <ol id="comments"></ol>
      </div>

    </div>

  </div>

  <script>
    "use strict";

    // colors based on http://alumni.media.mit.edu/~wad/color/palette.html
    const colors = [
      "rgb(0, 0, 0)",
      "rgb(87, 87, 87)",
      "rgb(173, 35, 35)",
      "rgb(42, 75, 215)",
      "rgb(29, 105, 20)",
      "rgb(129, 74, 25)",
      "rgb(129, 38, 192)",
      "rgb(160, 160, 160)",
      "rgb(129, 197, 122)",
      "rgb(157, 175, 255)",
      "rgb(41, 208, 208)",
      "rgb(255, 146, 51)",
      "rgb(255, 238, 51)",
      "rgb(233, 222, 187)",
      "rgb(255, 205, 243)",
      "rgb(255, 255, 255)",
    ];

    const colorNames = [
      "Black",
      "Dark Gray",
      "Red",
      "Blue",
      "Green",
      "Brown",
      "Purple",
      "Light Gray",
      "Light Green",
      "Light Blue",
      "Cyan",
      "Orange",
      "Yellow",
      "Tan",
      "Pink",
      "White",
    ];

    const countElement = document.getElementById('count');
    const errorElement = document.getElementById('error');
    const commentsElement = document.getElementById('comments');
    const colorsHolder = document.getElementById('colorsHolder');
    const commentForm = document.getElementById('commentForm');
    const welcomeForm = document.getElementById('welcome');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let currentColor = parseInt(localStorage.getItem('currentColor') || '0');
    let myName = localStorage.getItem('myName');
    let grid = [];

    canvas.onmousemove = mouseMovedOverCanvas;
    canvas.onclick = clickedCanvas;
    commentForm.onsubmit = sendMessage;

    setupColorChooser(currentColor, color => {
      currentColor = color;
      localStorage.setItem('currentColor', color);
    });

    const socket = connect(
      `ws://${location.host}/app`,
      {

        count(n) {
          countElement.innerText = n - 1;
        },

        canvas(canvas) {
          for (let i = 0; i < canvas.length; i++) {
            const hex = canvas.charAt(i);
            const c = parseInt(hex, 16);

            grid[i] = c;

            let x = i % 100;
            let y = Math.floor(i / 100);

            ctx.fillStyle = colors[c];
            ctx.fillRect(x * 10, y * 10, 10, 10);
          }
        },

        pixel({ x, y, c, hash }) {
          const i = y * 100 + x;

          grid[i] = c;

          paintSpot(x, y, c);
          showUserCircle(x, y, colorForHash(hash));
        },

        message(msg) {
          appendMessage(msg);
        },

        messages(messages) {
          commentsElement.innerHTML = '';
          for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            appendMessage(msg);
          }
        },

      }
    )

    let lastHoveredGridIndex = 0;
    function mouseMovedOverCanvas(e) {
      const { x, y } = coordinatesFor(event);
      const i = y * 100 + x;

      if (lastHoveredGridIndex == i)
        return;

      let oldX = lastHoveredGridIndex % 100;
      let oldY = Math.floor(lastHoveredGridIndex / 100);
      paintSpot(oldX, oldY, grid[lastHoveredGridIndex]);
      paintSpot(x, y, currentColor);

      lastHoveredGridIndex = i;
    }

    function paintSpot(x, y, c) {
      ctx.fillStyle = colors[c];
      ctx.fillRect(x * 10, y * 10, 10, 10);
    }

    // function repaintOne(i, c, userColor) {
    //   let x = i % 100;
    //   let y = Math.floor(i / 100);
    //   ctx.fillStyle = colors[c];
    //   ctx.fillRect(x * 10, y * 10, 10, 10);

    //   if (userColor) {
    //     const rect = canvas.getBoundingClientRect();

    //     const w = (rect.width / 100);
    //     const h = (rect.height / 100);

    //     const px = (x * w) + rect.left;
    //     const py = (y * h) + rect.top;

    //     const circle = document.createElement('div');
    //     circle.className = 'userEventCircle';
    //     circle.style.left = px - (w / 2) + 'px';
    //     circle.style.top = py - (h / 2) + 'px';
    //     circle.style.width = w * 2 + 'px';
    //     circle.style.height = h * 2 + 'px';
    //     circle.style.backgroundColor = userColor;
    //     document.body.appendChild(circle);

    //     setTimeout(() => {
    //       circle.classList.add('hiding');
    //       setTimeout(() => {
    //         circle.remove();
    //       }, 1000);
    //     }, 100);
    //   }
    // }

    const userCircles = {};
    let lts = 0;

    function showUserCircles(ts) {
      // const diff = ts - lts;

      // Object.entries(userCircles).forEach(([i, circle]) => {
      //   const { x, y, color, t } = circle;

      //   ctx.fillStyle = color;
      //   ctx.fillRect(x * 10, y * 10, 10, 10);

      //   console.log('circle', circle, x, y, color, t);
      //   // circle.t = 0;
      // });

      // // paintSpot()
      // console.log('painting...', diff);

      // lts = ts;
    }

    function showUserCircle(x, y, color) {
      const i = y * 100 + x;
      console.log(i, x, y, color);
      userCircles[i] = { x, y, color, t: 1000 };
      window.requestAnimationFrame(showUserCircles);
    }

    function clickedCanvas(event) {
      const { x, y } = coordinatesFor(event);
      socket.send({
        paint: { x, y, c: currentColor }
      });
    }

    function coordinatesFor(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.floor((event.clientX - rect.left) / (canvas.clientWidth / 100)),
        y: Math.floor((event.clientY - rect.top) / (canvas.clientHeight / 100)),
      };
    }

    function appendMessage(msg) {
      const commentEl = document.createElement('li');
      commentEl.className = 'comment';
      commentEl.innerText = msg.text;
      commentEl.style.color = colorForHash(msg.hash);
      commentsElement.insertAdjacentElement('afterbegin', commentEl);
    }

    function setupColorChooser(currentColor, fn) {
      colorsHolder.innerHTML = '';
      let selectedBox = null;
      for (let i = 0; i < 16; i++) {
        const colorBox = document.createElement('li');
        colorBox.className = 'colorBox';
        colorBox.style.backgroundColor = colors[i];
        colorBox.title = colorNames[i];
        colorBox.onclick = () => {
          if (selectedBox) {
            selectedBox.classList.remove('selected');
          }
          colorBox.classList.add('selected');
          selectedBox = colorBox;
          fn(i);
        };

        if (currentColor === i) {
          colorBox.onclick();
        }

        colorsHolder.appendChild(colorBox);
      }
    }

    function sendMessage(e) {
      e.preventDefault();
      let text = textbox.value;
      const maybeName = text.match(/^\/name (\w+)$/);
      if (myName) text = `[${myName}] ${text}`;
      textbox.value = '';
      socket.send({ text });

      if (maybeName && maybeName[1]) {
        myName = maybeName[1];
        localStorage.setItem('myName', myName);
      }
    }

    function connect(addr, handler) {
      const connection = new WebSocket(addr);

      connection.onclose = (e) => {
        window.onbeforeunload = null;
        showError("Disconnected; reloading.");
        setTimeout(() => window.location.reload(true), 500);
      }

      connection.onmessage = (message) => {
        const json = JSON.parse(message.data);
        Object.entries(json).forEach(([key, value]) => {
          handler[key](value);
        });
      }

      return {
        send(msg) {
          connection.send(JSON.stringify(msg));
        }
      }
    }

    function colorForHash(hash) {
      const hue = hash % 180 + 180;
      const sat = Math.abs(hash) % 50 + 30;
      const light = Math.abs(hash) % 60 + 20;
      return `hsl(${hue}, ${sat}%, ${light}%)`;
    }

    function showError(text) {
      errorElement.innerText = text;
      errorElement.classList.remove('hidden');
    }
  </script>
</body>

</html>