<!DOCTYPE html>
<html>

<head>
  <title>EditFight.com</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html {
      font-family: sans-serif;
    }

    *,
    *:before,
    *:after {
      box-sizing: border-box;
      font-family: inherit;
      margin: 0;
      padding: 0;
    }





    #error {
      position: fixed;
      z-index: 100;
      top: 35%;
      left: 0;
      right: 0;

      padding: 1em;
      background: crimson;
      color: white;
      text-align: center;
    }

    .hidden {
      display: none;
    }




    #page {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;

      display: flex;
      flex-direction: column;
    }

    #colorsHolder {
      flex-shrink: 0;
    }

    #rest {
      height: 100%;
      flex-grow: 1;

      display: flex;
      flex-direction: column;
    }

    #canvasHolder {
      flex: 1 1 auto;
    }

    #commentsHolder {
      flex: 1 20 auto;
      min-width: 20em;
    }

    @media (min-aspect-ratio: 3/4) {
      #rest {
        flex-direction: row;
      }
    }




    #colorsHolder {
      -webkit-overflow-scrolling: touch;
      background: #ccc;
    }

    #canvasHolder {
      padding: 10px;
      background: #9a9a9a;
      background-image: linear-gradient(45deg, #b4b4b4 25%, transparent 25%), linear-gradient(-45deg, #b4b4b4 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #b4b4b4 75%), linear-gradient(-45deg, transparent 75%, #b4b4b4 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    #commentsHolder {
      display: flex;
      flex-direction: column;

      background: #fff;
      padding: 0.5em;
    }

    #countHolder {
      font-size: 75%;
      opacity: 0.5;
      text-align: center;
    }

    #comments {
      -webkit-overflow-scrolling: touch;
      overflow: scroll;
      list-style-type: none;
    }

    .comment {
      margin: 0.5em 0;
    }

    .comment a {
      color: inherit;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;

      position: relative;
      cursor: crosshair;
    }

    #textbox {
      font-size: inherit;
      padding: 0.5em;
      width: 100%;
    }

    #colorsHolder {
      display: flex;
      overflow: auto;
      /* padding: 0.25em; */
    }

    .colorBox {
      position: relative;
      min-width: 2em;
      min-height: 2em;
      list-style-type: none;
      /* margin: 0.25em; */
    }

    .colorBox.selected {
      border-radius: 50%;
    }

    #welcome {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 2000;
      background: #e6e4d9;
      padding: 0 1em;
      overflow: auto;
    }

    #welcomeContent {
      margin: 0 auto;
      width: 95%;
      max-width: 30rem;
    }

    #welcomeContent>* {
      margin: 1rem 0;
    }

    #welcome button {
      background: #19a22d;
      border: 0;
      border-bottom: 3px solid #0e731d;
      padding: 0.5em 1em;
      font-size: inherit;
      border-radius: 3px;
      color: #fff;
      cursor: pointer;
    }

    #welcome .emphasis {
      font-weight: bold;
      color: crimson;
    }

    #welcome.hidden {
      display: none;
    }
  </style>
</head>

<body>

  <div id="error" class="hidden">
    There was once an error. One day, the error existed. The end.
  </div>

  <div id="page">

    <ol id="colorsHolder">
      Color chooser will go here soon.
    </ol>

    <div id="rest">

      <div id="canvasHolder">
        <canvas id="canvas" width="1000" height="1000"></canvas>
      </div>

      <div id="commentsHolder">
        <form autocomplete="off" id="commentForm">
          <input autofocus autocomplete="off" id="textbox" type="text" placeholder="Chat box">
        </form>
        <div id="countHolder">(There are
          <span id="count">n</span> other people here.)</div>
        <ol id="comments"></ol>
      </div>

    </div>

  </div>

  <script>
    "use strict";

    // colors based on http://alumni.media.mit.edu/~wad/color/palette.html
    const colors = [
      "rgb(0, 0, 0)",
      "rgb(87, 87, 87)",
      "rgb(173, 35, 35)",
      "rgb(42, 75, 215)",
      "rgb(29, 105, 20)",
      "rgb(129, 74, 25)",
      "rgb(129, 38, 192)",
      "rgb(160, 160, 160)",
      "rgb(129, 197, 122)",
      "rgb(157, 175, 255)",
      "rgb(41, 208, 208)",
      "rgb(255, 146, 51)",
      "rgb(255, 238, 51)",
      "rgb(233, 222, 187)",
      "rgb(255, 205, 243)",
      "rgb(255, 255, 255)",
    ];

    const colorNames = [
      "Black",
      "Dark Gray",
      "Red",
      "Blue",
      "Green",
      "Brown",
      "Purple",
      "Light Gray",
      "Light Green",
      "Light Blue",
      "Cyan",
      "Orange",
      "Yellow",
      "Tan",
      "Pink",
      "White",
    ];

    const countElement = document.getElementById('count');
    const errorElement = document.getElementById('error');
    const commentsElement = document.getElementById('comments');
    const colorsHolder = document.getElementById('colorsHolder');
    const commentForm = document.getElementById('commentForm');
    const welcomeForm = document.getElementById('welcome');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let currentColor = parseInt(localStorage.getItem('currentColor') || '0');
    let myName = localStorage.getItem('myName');
    let grid = [];

    for (let y = 0; y < 100; y++) {
      const row = [];
      for (let x = 0; x < 100; x++) {
        row.push(0);
      }
      grid.push(row);
    }

    canvas.onmousemove = mouseMovedOverCanvas;
    canvas.onclick = clickedCanvas;
    canvas.onmouseleave = mouseLeftCanvas;
    commentForm.onsubmit = sendMessage;
    document.onvisibilitychange = redrawEverything;

    setupColorChooser(currentColor, color => {
      currentColor = color;
      localStorage.setItem('currentColor', color);
    });

    const socket = connect(
      `ws://${location.host}/app`,
      {

        count(n) {
          countElement.innerText = n - 1;
        },

        canvas(canvas) {
          for (let i = 0; i < canvas.length; i++) {
            const hex = canvas.charAt(i);
            const c = parseInt(hex, 16);

            let x = i % 100;
            let y = Math.floor(i / 100);

            grid[y][x] = c;

            ctx.fillStyle = colors[c];
            ctx.fillRect(x * 10, y * 10, 10, 10);
          }
        },

        pixels(pixels) {
          pixels.forEach(({ x, y, c, hash }) => {
            grid[y][x] = c;
            paintSpot(x, y, c);

            if (hash) {
              showUserCircle(x, y, colorForHash(hash));
            }
          });
        },

        message(msg) {
          appendMessage(msg);
        },

        messages(messages) {
          commentsElement.innerHTML = '';
          for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            appendMessage(msg);
          }
        },

      }
    )

    let lastHoveredSpot = null;
    function mouseMovedOverCanvas(e) {
      const newSpot = coordinatesFor(e);
      const { x, y } = newSpot;

      if (lastHoveredSpot && lastHoveredSpot.x === x && lastHoveredSpot.y === y)
        return;

      if (lastHoveredSpot) {
        const { x, y } = lastHoveredSpot;
        paintSpot(x, y, grid[y][x]);
      }

      paintSpot(x, y, currentColor);

      lastHoveredSpot = newSpot;
    }

    function mouseLeftCanvas(e) {
      const { x, y } = lastHoveredSpot;
      paintSpot(x, y, grid[y][x]);
      lastHoveredSpot = null;
    }

    function paintSpot(x, y, c) {
      ctx.fillStyle = colors[c];
      ctx.fillRect(x * 10, y * 10, 10, 10);
    }

    function redrawEverything() {
      for (let y = 0; y < 100; y++) {
        for (let x = 0; x < 100; x++) {
          paintSpot(x, y, grid[y][x]);
        }
      }
    }

    const userCircles = {};

    function showUserCircles(ts) {
      Object.entries(userCircles).forEach(([i, circle]) => {
        const { x, y, color } = circle;

        const diff = circle.lastTime ? ts - circle.lastTime : 0;
        circle.lastTime = ts;

        circle.t -= diff;
        if (circle.t < 0) {
          delete userCircles[i];
          return;
        }

        paintSpot(x, y, grid[y][x]);

        ctx.globalAlpha = circle.t / 1000.0;
        ctx.fillStyle = color;
        // ctx.beginPath();
        // ctx.arc(
        //   (x * 10) + 5,
        //   (y * 10) + 5,
        //   5,
        //   0, 2 * Math.PI);
        // ctx.fill();
        ctx.fillRect(x * 10, y * 10, 10, 10);
        ctx.globalAlpha = 1.0;
      });

      if (Object.keys(userCircles).length > 0) {
        window.requestAnimationFrame(showUserCircles);
      }
    }

    function showUserCircle(x, y, color) {
      const i = y * 100 + x;
      userCircles[i] = { x, y, color, t: 1000 };
      window.requestAnimationFrame(showUserCircles);
    }

    function clickedCanvas(event) {
      const { x, y } = coordinatesFor(event);
      socket.send({
        paint: { x, y, c: currentColor }
      });
    }

    function coordinatesFor(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.floor((event.clientX - rect.left) / (canvas.clientWidth / 100)),
        y: Math.floor((event.clientY - rect.top) / (canvas.clientHeight / 100)),
      };
    }

    function appendMessage(msg) {
      const commentEl = document.createElement('li');
      commentEl.className = 'comment';
      commentEl.innerText = msg.text;
      commentEl.innerHTML = commentEl.innerHTML.replace(/(https?:\/\/[^\s]+)/g, "<a href='$1' target=_blank rel=noopener>$1</a>");
      commentEl.style.color = colorForHash(msg.hash);
      commentsElement.insertAdjacentElement('afterbegin', commentEl);
    }

    function setupColorChooser(currentColor, fn) {
      colorsHolder.innerHTML = '';
      let selectedBox = null;
      for (let i = 0; i < 16; i++) {
        const colorBox = document.createElement('li');
        colorBox.className = 'colorBox';
        colorBox.style.backgroundColor = colors[i];
        colorBox.title = colorNames[i];
        colorBox.onclick = () => {
          if (selectedBox) {
            selectedBox.classList.remove('selected');
          }
          colorBox.classList.add('selected');
          selectedBox = colorBox;
          fn(i);
        };

        if (currentColor === i) {
          colorBox.onclick();
        }

        colorsHolder.appendChild(colorBox);
      }
    }

    function sendMessage(e) {
      e.preventDefault();
      let text = textbox.value;
      if (text.trim().length === 0) return;

      const maybeName = text.match(/^\/name (\w+)$/);
      if (myName) text = `[${myName}] ${text}`;
      textbox.value = '';
      socket.send({ text });

      if (maybeName && maybeName[1]) {
        myName = maybeName[1];
        localStorage.setItem('myName', myName);
      }
    }

    function connect(addr, handler) {
      const connection = new WebSocket(addr);

      connection.onclose = (e) => {
        window.onbeforeunload = null;
        showError("Disconnected; reloading.");
        setTimeout(() => window.location.reload(true), 500);
      }

      connection.onmessage = (message) => {
        const json = JSON.parse(message.data);
        Object.entries(json).forEach(([key, value]) => {
          handler[key](value);
        });
      }

      return {
        send(msg) {
          connection.send(JSON.stringify(msg));
        }
      }
    }

    function colorForHash(hash) {
      const hue = hash % 180 + 180;
      const sat = Math.abs(hash) % 50 + 30;
      const light = Math.abs(hash) % 60 + 20;
      return `hsl(${hue}, ${sat}%, ${light}%)`;
    }

    function showError(text) {
      errorElement.innerText = text;
      errorElement.classList.remove('hidden');
    }
  </script>
</body>

</html>